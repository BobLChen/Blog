---
title: 骨骼动画简介
date: 2019-08-07 07:52:40
tags:
- Vulkan
- 物理设备
- 3D
- Demo
categories:
- Vulkan
---

[项目Github地址请戳我](https://github.com/BobLChen/VulkanDemos)

## 1、骨架

骨架由一系列具有层次关系的关节(骨骼)组成，是一种树结构。可以通过平移和旋转根关节来确定整个骨架在模型空间中的位置和方向。父关节运动能影响子关节运动，但子关节运动对父关节不产生影响。因此平移、旋转、缩放父关节时，也会同时平移、旋转、缩放其所有子关节。

<!-- more -->

![0.png](0.png)

## 2、骨骼的表示

通常会将骨骼进行编号[0,N−1],编号也是关节索引。一个骨骼包含以下信息:
- 名称
- 索引
- 父骨骼索引
- BindPose(可能是逆变换，后面再说)

```c++
struct Joint
{
    std::string  name;
    int32        index;
    int32        parent;
    Matrix4x4    bindPose;
    // Matrix4x4 inverseBindPose;
};
```

## 3、姿态

把关节旋转、平移、缩放，就能为骨架摆出各种姿势。关节的姿势被定义为关节相对于某坐标系的位置、朝向、缩放。通常骨架存在绑定姿势、局部姿势、全局姿势。

### 绑定姿势

绑定姿势是网格绑定到骨骼之前的姿势，也就是将网格当作正常`没有蒙皮`的姿势，通常是美术绑定模型时预设的。下图左边是绑定姿势，右图是某个运动状态的姿势：

![1.png](1.png)

### 局部姿势

局部姿势是关节相对于父关节的位置、缩放、旋转状态。局部姿势存储为TQS的格式，表示相对与父关节的位置、朝向、缩放。

### 全局姿势

全局姿势是相对于局部姿势而言的，它是关节相对于模型空间的姿势（局部姿势是相对于父关节的姿势）。假设某个关节`J`坐标空间的点`q`需要转换到全局空间，那么可以通过从该关节`J`开始一直遍历到根关节，即可将`q`变换到`世界坐标系(模型空间)`中表示的坐标形式。

![2.png](2.png)

如上图所示，左边是人体骨架名称，右边是对应的标号。现在假我们将关节`rfemur`空间的点`q`变换到`世界坐标系(模型空间)`中,`rfemur`关节编号是8，我们用P8表示它的局部姿势矩阵，以此类推，那么`q`在世界坐标系中`q′`的坐标可以表示为：
```C++
q′ = P1 x P7 x P8 x q
```
对应的变换矩阵是`P1P7P8`,该变换矩阵便是关节`8`的`全局姿势矩阵`。它直接将关节`8坐标系下`的`点`变换到世界坐标系中。我们知道变换矩阵的`逆`表示`逆变换`，那么`全局姿势矩阵`的`逆矩阵`可以将`世界空间(模型空间)`的点变换到`关节空间中`。那么在世界坐标系中`q′`的坐标可以通过逆变换转化到关节`rfemur`空间的点`q`。
```C++
q = inverse(P1 x P7 x P8) x q′
```

**这个逆矩阵非常关键。**

## 4、蒙皮

蒙皮就是计算骨架在**某一状态**下网格**顶点的位置**。每个顶点可以绑定到一个或者多个骨骼（一般四个），动画播放时**顶点随着关节运动**。顶点的**最终变换**就等于它所**绑定的骨架变换的加权和**。对于每个顶点，我们需要有以下信息：

- 骨骼索引(四个)
- 骨骼应用权重(四个)

### 蒙皮矩阵

蒙皮矩阵就是把顶点从**绑定姿势**变换到骨骼的**当前姿势**的矩阵，注意顶点的变换前后都是在**模型空间中**。

```
FinalPosition = Bone0 * V * Weight0 + Bone1 * V * Weight1 + Bone2 * V * Weight2 + Bone3 * V * Weight3
```

**Bone0、Bone1、Bone2、Bone3**代表关节的**全局变换矩阵**与**BindPose**的**全局变换矩阵的逆变换**。

这里就有一个需要注意的地方：我们的顶点是**绑定姿态**时的坐标，这个坐标是在模型空间中的。假设一个**绑定姿态**下的顶点**V(Global)**，它对应的骨骼空间中的点为**v(local)**，根据第三节**姿态**章节里面描述，我们可以知道。

```
V = P1 x P7 x P8 x v
```

那么顶点**V**对应的关节局部空间的顶点**v**就可以通过逆变换矩阵计算出来：

```
v = inverse(P1 x P7 x P8) x V
```

我们为什么要将**模型空间的顶点**转化到**关节局部空间**？

可能有人会有疑问，为什么要做这个操作？回想前面提到的，在关节局部空间的**顶点p**可以通过**P1 x P7 x P8**(也是关节的Global变换矩阵)矩阵变换到**模型空间**。我们存储的是关节**相对于**父关节的**变换矩阵**，经过了一系列的变换，我们可以计算出关节在模型空间下的**全局变换矩阵**(模型空间)。

但是我们加载出来的模型的**顶点**确是在**模型空间**中。那么显然我们不能将加载出来的顶点直接应用到关节的**全局变换**上。关节的**全局变换矩阵**的作用是将**关节空间**下的**顶点v**通过**全局变换矩阵**变换到**模型空间**。现在我们拿到手的顶点都**没有**在关节局部空间，**而是**在模型空间，显然**不能**将一个**已经**变换到模型空间的顶点，再次拿去经过一次全局变换。

解决这个问题其实也很简单，既然我们拿到的是**模型空间**下的**顶点V**，那么我们把它转化到**关节空间v**里面去不就行了嘛！这样我们不就有了一个在**关节空间**下的**顶点v**，那我们就可以应用关节的**全局变换**把它变到**模型空间**了。

### 绑定姿态

之前谈到了绑定姿态，也知道了是绑定骨骼之前用到的一个姿态。虽然没有任何蒙皮，动画信息，但是它总归是一个姿态。之前我们推导出，如果我们需要将顶点应用到关节的**全局变换**，那么我们就需要将模型空间的**顶点V**经过逆变换，变换到关节的局部空间。

我们加载出来的模型也是美术预设的模型，它就是**绑定姿态(BindPose)**。那么其实我们只需要将**绑定姿态**的关节的**局部变换矩阵**或者**全局变换矩阵**存储下来，然后通过骨骼的关系，把每个关节的**全局变换矩阵**计算出来，最后对**全局变换矩阵**取逆，就得到了我们需要的逆矩阵。通过这个逆矩阵，我们就可以将绑定姿态下的顶点转化到关节的局部空间。

### 关节空间下的顶点

值得一提的是，如果一个顶点在关节空间中，那么无论我们的关节如何运动，这个顶点相对于关节来说它永远都是不变的。这个也跟骨架的原理一样，如果只是根节点在运动，那么子关节相对于根节点来讲也是不变的。就好比我们把我们整个手臂抡圆了转圈甩，你的手指相对于你手臂来讲，它是不变的，但是它随着手臂的运动在全局空间里面表现出来是运动状态。

为什么要提这个呢？是因为顶点在关节的局部空间是不变的，那么我们只要拥有在关节局部空间的顶点即可，不管它是通过**BindPose**计算出来的，但是通过其它**Pose**计算出来的，但它总归是在关节的局部空间中。

其实这里就引申了出了，我们可以不存储**BindPose**状态下的模型数据，我们其实可以存储动画**某个时刻**的**模型数据**，然后我们将**这个时刻**的**关节数据**存储下来，把这个时刻的关节数据用来做逆变换其实也是可以的。我们不一定是非得需要**BindPose**。

## 5、动画

如果上一节看懂了，那么大家可能也会有另外一个疑问。我特么**顶点V**已经是模型空间下了，我再把它通过**BindPose**的**全局变换矩阵的逆矩阵**转换到关节的**局部空间**，然后我再通过**BindPose**下关节的**全局变换矩阵**把它局部空间的顶点v变换到模型空间，这不还是原来的**顶点V**？？？这不是吃饱了撑的？？？

但是如果关节运动起来了，那么就很有意思了。假设有一个攻击的动画，整个持续时间1S。那么整个骨架里面的关节在这1S内都会运动，这个时候如果我们每隔**0.0166666666666667**秒就把关节当前相对于父关节**的旋转、缩放、位移**的信息存储下来。这样我们就有了**60组**数据，每一组存储了每一个时刻关节的信息。

现在我们把关节空间下的**顶点v**应用到**某一组**的关节的**全局变换矩阵**上，那么这个顶点就是在**这个时刻**的**模型空间**下的坐标。整个动画的原理其实就这样，我们按照一定的帧率记录每一帧所有关节在当前时间节点的**旋转、位移、缩放**信息。然后应用到顶点上，让顶点从模型空间变换到新的模型空间。



